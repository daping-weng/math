<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Le Diagram Drawer</title>
        <link rel="icon" href="plabic_graph.png" type="image/icon type">
        <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
        <script src = "gauss-jordan.js"></script>
    </head>
    <style>
        #canvas_column {
            float: left;
            width: 850px;
            padding: 10px;
            height: 600px; 
            display:table-cell;
        }    
    </style>
    <body>
        <form>
            <br>
            <label for="dec_perm">Permutation without fixed points:</label> &nbsp; <input type="text" id="dec_perm" name="dec_perm" value="3,4,1,2"> &nbsp; &nbsp; &nbsp;
            <label for="le_diag">Le diagram</label> <input type="checkbox" id="le_diag" name="le_diag" value="yes" checked> &nbsp; &nbsp; &nbsp;
            <label for="face_label">Labelings</label><input type="checkbox" id="face_label" name="face_label" value="yes" checked> &nbsp; &nbsp; &nbsp;
            <label for="quiver">Quiver arrows</label> <input type="checkbox" id="quiver" name="quiver" value="yes" checked> &nbsp; &nbsp; &nbsp;
            <label for="labeling_type">Type of labelings</label><input type="radio" id="target" name="label_type" value="Target" checked> <label for="target">Target</label>
            <input type="radio" id="source" name="label_type" value="Source"> <label for="source">Source</label>
        </form>
        <br>
            <label for="order">Choose a minimum element for the linear order:</label>&nbsp; <input type="text" id="order" name="dec_perm" value="1" size="2"> &nbsp; &nbsp;
            <button type="button" onclick="draw()">Draw</button> &nbsp; &nbsp; <label id="output"></label>
        <br>
        <br>
        <div class="row">
            <div id="canvas_column">
                <canvas id="diagram" width="800" height="500" style="border:1px solid #000000;"></canvas>
            </div>
        <div class="column">
            <div id="info">To convert the diagram to a plabic graph, please do the following replacement on your own. </div>
            <p><img src="Replacement.png" wideth="400" height="400"></p>
            <p>Please also see P. Galashin's <a href="https://www.math.ucla.edu/~galashin/plabic.html">website</a> for a connection to plabic tilings.</p>
    </body>


    <script>
        var diag = document.getElementById("diagram");
        var ctx = diag.getContext("2d");
        var plucker_label = [];
        var state = 0;
        var h_gap = 0;
        var v_gap = 0;
        var nolistener = true;
        var double = [];
        var seed =[];
        var top_left_label =[];
        var original_perm = [];
        var n = 0;
        var grass_neck = [];
        var source_grass_neck = [];
        var min_element = 0;
        var outer_poisson = [];
        var fr_mat = [];

        function rank(p) { //computes the rank of a permutation
            var r = 0;
            for (var i=0;i<p.length;i++) {
                if (p[i] > i+1) {
                    r += p[i]-i-1;
                } else {
                    r += p[i]+p.length-i-1;
                }
            }
            return (parseInt(r/p.length));
        }

        function targetGrassNeck(p) {
            var new_term = [];
            for (var i=0;i<p.length;i++) { //the first term in the Grassmann necklace consists of indices pi(i) with pi(i)<i.
                if (p[i] <= i+1) {
                    new_term.push(p[i]);
                }
            }
            new_term.sort(function(a, b){return a-b});
            var output = [new_term.slice()];
            for (var i=0;i<p.length;i++) {
                for (var j=0;j<new_term.length;j++) { //the next term in the Grassmann necklace can be obtained by replacing pi(i) with i.
                    if (new_term[j] == i+1) {
                        new_term.splice(j,1,p[i]);
                        break;
                    }
                }
                new_term.sort(function(a, b){return a-b});
                output.push(new_term.slice());
            }
            output.pop(); //the last one is the same as the first one, so we delete it.
            console.log(output);
            return(output);
        }

        function decYoungDiag(p) { //the output is a matrix with -1 at the lower right hand corner, a single 1 at each face of the Le diagram, and 0 everywhere else.
            m = rank(p);
            l = p.length-m;
            var output = [];
            for (var i=0;i<m;i++) {
                output.push([]);
                for (var j=0;j<l;j++) {
                    output[i].push(0);
                }
            }
            I = targetGrassNeck(p)[0];
            for (var i=1;i<m;i++) {
                if (I[i] > i+1) {
                    for (var k=0;k<I[i]-i-1;k++) {
                        output[i][l-k-1] = -1;
                    }
                }
            }
            J = [];
            for (var j=0;j<p.length;j++) {
                if (!I.includes(j+1)) {
                    J.push(j+1);
                }
            }
            J.reverse();
            K = I.slice();
            L = J.slice();
            for (var j=0;j<l;j++) {
                for (var i=0;i<m;i++) {
                    if (output[m-i-1][l-j-1] >= 0) {
                        if (p[I[m-i-1]-1] != K[m-i-1] && p[J[l-j-1]-1] != L[l-j-1]) {
                            output[m-i-1][l-j-1] = 1;
                            var xxx = I[m-i-1];
                            I[m-i-1] = J[l-j-1];
                            J[l-j-1] = xxx;
                        }
                    }
                }
            }
            return(output);
        }

        function left_one(mat,i,j) { // given a matrix, it finds the 1 to the left of an entry.
            for (var k=0;k<j;k++) {
                if (mat[i][j-k-1]==1) {
                    return([i,j-k-1]);
                }
            }
            return([-1,-1]);
        }

        function above_one(mat,i,j) { //given a matrix, it finds the 1 above an entry.
            for (var k=0;k<i;k++) {
                if (mat[i-k-1][j]==1) {
                    return([i-k-1,j]);
                } 
            }
            return([-1,-1]);
        }

        function check00(pt) { //check and see if it is (-1,-1), i.e, the upper left frozen.
            if (pt[0]<0 && pt[1]<0) {
                return(false);
            } else {
                return(true);
            }
        }

        //There are two types of zig-zag paths in these Le diagrams, one is a hook downward (type 0) and the other is a hook to the right (type 1).

        function zigzag(mat,i) {
            var m = mat.length;
            var l = mat[0].length;
            var start_pt = [0,l,"left"];
            for (var j=1;j<i;j++) {
                if (start_pt[2] == "left") {
                    if (start_pt[0] == m-1) {
                        start_pt[0] += 1;
                        start_pt[1] -= 1;
                        start_pt[2] = "up";
                    } else if (mat[start_pt[0]+1][start_pt[1]-1]>=0) {
                        start_pt[0] += 1;
                    } else {
                        start_pt[0] += 1;
                        start_pt[1] -= 1;
                        start_pt[2] = "up";
                    }
                } else {
                    if (start_pt[0] == m) {
                        start_pt[1] -= 1;
                    } else if (mat[start_pt[0]][start_pt[1]-1]>=0) {
                        start_pt[2] = "left";
                    } else {
                        start_pt[1] -= 1;
                    }
                }
            }
            var pt = start_pt.slice();
            var path = [[pt[0],pt[1]]];
            while (pt[2] == "left" || pt[2] == "up"){
                if (pt[2] == "left") {
                    if (check00(left_one(mat,pt[0],pt[1]))) {
                        pt[1] = left_one(mat,pt[0],pt[1])[1];
                        pt[2] = "up";
                        path.push([pt[0],pt[1]]);
                    } else {
                        return(path);
                    }
                } else {
                    if (check00(above_one(mat,pt[0],pt[1]))) {
                        pt[0] = above_one(mat,pt[0],pt[1])[0];
                        pt[2] = "left";
                        path.push([pt[0],pt[1]]);
                    } else {
                        return(path);
                    }
                }
            }
        }

        function arrow(a,b) {
            var angle = 0;
            if (b[0]==a[0]) {
                angle = Math.sign(b[1]-a[1])*Math.PI/2;
            }
            else {
                angle = Math.atan2(b[1]-a[1],b[0]-a[0]);
            }
            ctx.beginPath();
            ctx.moveTo(a[0]+(b[0]-a[0])/10,a[1]+(b[1]-a[1])/10);
            ctx.lineTo(b[0]-(b[0]-a[0])/10,b[1]-(b[1]-a[1])/10);
            ctx.strokeStyle = "green";
            ctx.stroke();
            ctx.moveTo(b[0]-(b[0]-a[0])/10+5*Math.cos(angle+Math.PI*3/4), b[1]-(b[1]-a[1])/10+5*Math.sin(angle+Math.PI*3/4));
            ctx.lineTo(b[0]-(b[0]-a[0])/10,b[1]-(b[1]-a[1])/10);
            ctx.lineTo(b[0]-(b[0]-a[0])/10+5*Math.cos(angle-Math.PI*3/4), b[1]-(b[1]-a[1])/10+5*Math.sin(angle-Math.PI*3/4));
            ctx.stroke();
            ctx.strokeStyle = "black";
            ctx.closePath();
        }

        function inList(a,b){ //checks and see if the list a is contained in the list b, which is a list of lists.
            for (var t=0;t<b.length;t++) {
                var identical = true;
                for (var k=0;k<a.length;k++) {
                    if (a[k]!==b[t][k]) {
                        identical = false;
                        break;
                    }
                }
                if (identical) {
                    return (t);
                }
            }
            return(-1);
        }

        function targetToSource(a) {
            var output=[];
            for (var t=0;t<a.length;t++) {
                output.push(original_perm.indexOf(a[t])+1);
            }
            output.sort((x,y)=>x-y);
            return(output);
        }

        function reorder(a,i) { //reorder elements in a with respect to the linear ordering with i being the biggest.
            var output = [];
            for (var t=0;t<a.length;t++) {
                output.push(a[t]);
            }
            output.sort((x,y)=>((x+n-i-1)%n)-((y+n-i-1)%n));
            return(output);
        }

        function forward_shift(p,i) { //shifts indices forward by i
            for (var t=0;t<p.length;t++) {
                p[t] -= i-1;
                if (p[t]<=0) {
                    p[t]+=p.length;
                }
            }
            for (var k=0;k<i-1;k++) {
                p.push(p.shift());
            }
            return(p);
        }

        function backward_shift(p,i) { //shifts indices backward by i
            for (var t=0;t<p.length;t++) {
                p[t] += i-2;
                p[t] = p[t]%n;
                p[t] += 1;
            }
            p.sort(function(a, b){return a-b});
            return(p);
        }

        function simple_pairing(l1,l2) { //computes the Poisson bracket between two weakly separated Pluckers.
            var x = l1.filter(t=>!l2.includes(t));
            var y = l2.filter(s=>!l1.includes(s));
            x.sort(function(a, b){return a-b});
            y.sort(function(a, b){return a-b});
            var power = 0
            for (var i=0;i<x.length;i++) {
                if (y[i]>x[i]) {
                    power += 1;
                } else if (y[i]<x[i]) {
                    power -= 1;
                }
            }
            return(power/2);
        }

        function monomial_pairing(a,b,c,d) { //computes the Poisson bracket between two Laurent monomials of weakly separated Pluckers.
            var output = 0;
            for (var i=0;i<a.length;i++) {
                for (var j=0;j<c.length;j++) {
                    output += simple_pairing(a[i],c[j]);
                }
            }
            for (var i=0;i<b.length;i++) {
                for (var j=0;j<c.length;j++) {
                    output -= simple_pairing(b[i],c[j]);
                }
            }
            for (var i=0;i<a.length;i++) {
                for (var j=0;j<d.length;j++) {
                    output -= simple_pairing(a[i],d[j]);
                }
            }
            for (var i=0;i<b.length;i++) {
                for (var j=0;j<d.length;j++) {
                    output += simple_pairing(b[i],d[j]);
                }
            }
            return(output);
        }

        function ex_mat(dyd) { //generates the Le seed. The output is a triple: the vertex index for each face, where the vertex is in the decorated Young diagram, and the exchange matrix. In particular, the top left face is at the end.
            var dyd_entry_label = [];
            var m = dyd.length;
            var n = m + dyd[0].length;
            for (var i=0;i<dyd.length;i++) {
                dyd_entry_label.push([]);
                for (var j=0;j<dyd[0].length;j++) {
                    dyd_entry_label[i].push(-1);
                }
            }
            var k = 0;
            var vertex_label = [];
            for (var j=0;j<n-m;j++) {
                for (var i=0;i<m;i++) {
                    if (dyd[m-i-1][n-m-j-1]==1) {
                        dyd_entry_label[m-i-1][n-m-j-1] = k;
                        vertex_label.push([m-i-1,n-m-j-1]);
                        k += 1;
                    }
                }
            }
            vertex_label.push([-0.75,-0.75]);
            var mat = [];
            for (var i=0;i<k+1;i++) {
                mat.push([])
                for (var j=0;j<k+1;j++) {
                    mat[i].push(0);
                }
            }
            for (var j=0;j<n-m;j++) {
                var cycle = [];
                for (var i=0;i<m;i++) {
                    if (dyd[m-i-1][n-m-j-1] == 1) {
                        cycle.push([m-i-1,n-m-j-1]);
                        if (cycle.length>1 && check00(left_one(dyd,m-i-1,n-m-j-1))) {
                            cycle.push(left_one(dyd,m-i-1,n-m-j-1));
                            cycle.push(cycle[0].slice());
                            for (var t=0;t<cycle.length-1;t++) {
                                mat[dyd_entry_label[cycle[t][0]][cycle[t][1]]][dyd_entry_label[cycle[t+1][0]][cycle[t+1][1]]] = 1;
                                mat[dyd_entry_label[cycle[t+1][0]][cycle[t+1][1]]][dyd_entry_label[cycle[t][0]][cycle[t][1]]] = -1;
                            }
                            cycle = [];
                            if (check00(above_one(dyd,m-i-1,n-m-j-1))) {
                                i -= 1;
                            }
                        } else if (cycle.length>1 && !check00(above_one(dyd,m-i-1,n-m-j-1))) {
                            var top_left = true;
                            for (var t=1;t<n-m-j;t++) {
                                if (check00(above_one(dyd,m-i-1,n-m-j-t-1))) {
                                    top_left = false;
                                    cycle.push(above_one(dyd,m-i-1,n-m-j-t-1));
                                    cycle.push(cycle[0].slice());
                                    break;
                                }
                            }
                            if (top_left) {
                                cycle.push(0);
                                cycle.push(cycle[0].slice());
                            }
                            for (var t=0;t<cycle.length-1;t++) {
                                if (cycle[t] == 0) {
                                    mat[k][dyd_entry_label[cycle[t+1][0]][cycle[t+1][1]]] = 1;
                                    mat[dyd_entry_label[cycle[t+1][0]][cycle[t+1][1]]][k] = -1;
                                } else if (cycle[t+1] == 0) {
                                    mat[k][dyd_entry_label[cycle[t][0]][cycle[t][1]]] = -1;
                                    mat[dyd_entry_label[cycle[t][0]][cycle[t][1]]][k] = 1;
                                } else {
                                    mat[dyd_entry_label[cycle[t][0]][cycle[t][1]]][dyd_entry_label[cycle[t+1][0]][cycle[t+1][1]]] = 1;
                                    mat[dyd_entry_label[cycle[t+1][0]][cycle[t+1][1]]][dyd_entry_label[cycle[t][0]][cycle[t][1]]] = -1;
                                }
                            }
                            cycle = [];
                        } 
                    }
                }
            }
            console.log("The triple (diagram_label, quiver_vertex_label, exchange_matrix) is");
            console.log([dyd_entry_label,vertex_label,mat]);
            return([dyd_entry_label,vertex_label,mat]);
        }


        function acoord(location) { //outputs the Plucker of the selected face.
            if (location == 0) {
                return(top_left_label);
            } else {
                return(plucker_label[location[0]][location[1]]);
            }
        }

        function xcoord(location) { //outputs the X coordinate of the selected face.
            var a = [];
            var b = [];
            var c = [];
            if (location == 0) {
                for (var i=0;i<seed[1].length;i++) {
                    if (seed[2][seed[1].length-1][i] == 1) {
                        a.push(plucker_label[seed[1][i][0]][seed[1][i][1]]);
                    }
                }
                a.push(grass_neck[0]);
                for (var i=0;i<seed[1].length;i++) {
                    if (seed[2][seed[1].length-1][i] == -1) {
                        b.push(plucker_label[seed[1][i][0]][seed[1][i][1]]);
                    }
                }
                b.push(grass_neck[n-1]);
                c.push((min_element-2+n)%n+1);
            } else {
                for (var i=0;i<seed[1].length;i++) {
                    if (seed[2][seed[0][location[0]][location[1]]][i] == 1) {
                        if (i == seed[1].length-1) {
                            a.push(top_left_label);
                        } else {
                            a.push(plucker_label[seed[1][i][0]][seed[1][i][1]]);
                        }
                    }
                }
                for (var i=0;i<seed[1].length;i++) {
                    if (seed[2][seed[0][location[0]][location[1]]][i] == -1) {
                        if (i == seed[1].length-1) {
                            b.push(top_left_label);
                        } else {
                            b.push(plucker_label[seed[1][i][0]][seed[1][i][1]]);
                        }
                    }
                }
                var t = inList(plucker_label[location[0]][location[1]],grass_neck);
                if (t>=0) {
                    a.push(grass_neck[t%n]);
                    b.push(grass_neck[(t-1+n)%n]);
                    c.push((t-2+min_element+n)%n+1);
                }
	        }
            return([a,b,c]);
        }

    

        function draw() {
            top_left_label = [];
            state = 0;
            seed = [];
            plucker_label = [];
            ctx.clearRect(0, 0, 800,500);
            var le_diag = document.getElementById("le_diag").checked;
            var face_label = document.getElementById("face_label").checked;
            var target_label = document.getElementById("target").checked;
            var quiver = document.getElementById("quiver").checked;
            min_element = parseInt(document.getElementById("order").value);
            original_perm = document.getElementById("dec_perm").value.split(",");
            n = original_perm.length;
            var perm = [];
            for(var i=0;i<original_perm.length;i++) {
                original_perm[i] = parseInt(original_perm[i]);
                perm.push(original_perm[i]);
                    if (original_perm[i]>n || original_perm[i]==i+1) {
                        window.alert("This is not a permutation without fixed points.");
                    }
            }
            if (min_element > perm.length) {
                window.alert("Please choose a number from 1 to n to break the cyclic order on [n].");
            }
            perm = forward_shift(perm,min_element);
            var m = rank(perm);
            var dyd = decYoungDiag(perm);
            console.log("the decorated Young diagram is");
            console.log(dyd);
            h_gap = 800/(n-m+1);
            v_gap = 600/(m+1);
            if (le_diag) {
                ctx.beginPath();
                for (var i=0;i<m;i++) {
                    for (var j=0;j<n-m;j++) {
                        if (dyd[i][j]==0) {
                            if (check00(above_one(dyd,i,j))) {
                                ctx.moveTo(h_gap*(j+0.5),v_gap*i);
                                ctx.lineTo(h_gap*(j+0.5),v_gap*(i+1));
                                ctx.stroke();
                            } else if (check00(left_one(dyd,i,j))) {
                                ctx.moveTo(h_gap*j,v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+1),v_gap*(i+0.5));
                                ctx.stroke();
                            } 
                        } else if (dyd[i][j]==1) {
                            if (check00(above_one(dyd,i,j)) && check00(left_one(dyd,i,j))) {
                                ctx.moveTo(h_gap*(j+0.5),v_gap*i);
                                ctx.lineTo(h_gap*(j+0.5),v_gap*(i+1));
                                ctx.stroke();
                                ctx.moveTo(h_gap*j,v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+1),v_gap*(i+0.5));
                                ctx.stroke();
                            } else if (check00(left_one(dyd,i,j))) {
                                ctx.moveTo(h_gap*j,v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+1),v_gap*(i+0.5));
                                ctx.stroke();
                                ctx.moveTo(h_gap*(j+0.5),v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+0.5),v_gap*(i+1));
                                ctx.stroke();
                            } else if (check00(above_one(dyd,i,j))) {
                                ctx.moveTo(h_gap*(j+0.5),v_gap*i);
                                ctx.lineTo(h_gap*(j+0.5),v_gap*(i+1));
                                ctx.stroke();
                                ctx.moveTo(h_gap*(j+0.5),v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+1),v_gap*(i+0.5));
                                ctx.stroke();
                            } else {
                                ctx.moveTo(h_gap*(j+1),v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+0.5),v_gap*(i+0.5));
                                ctx.stroke();
                                ctx.moveTo(h_gap*(j+0.5),v_gap*(i+0.5));
                                ctx.lineTo(h_gap*(j+0.5),v_gap*(i+1));
                                ctx.stroke();
                            }
                        }
                    }
                }
                ctx.closePath();
            }
            for (var i=0;i<m;i++) {
                plucker_label.push([]);
                for (var j=0;j<n-m;j++) {
                    plucker_label[i].push([]);
                }
            }
            for (var k=0;k<n;k++) {
                var path = zigzag(dyd,k+1);
                if (le_diag) {
                    ctx.textAlign = "center";
                    if (path[0][0]==path[1][0]) {
                        ctx.fillText(String(backward_shift([k+1],min_element)),h_gap*(path[0][1]+0.1),v_gap*(path[0][0]+0.5));
                    } else {
                        ctx.fillText(String(backward_shift([k+1],min_element)),h_gap*(path[0][1]+0.5),v_gap*(path[0][0]+0.1));
                    }
                }
                for (var i=0;i<m;i++) {
                    for (var j=0;j<n-m;j++) {
                        if (dyd[i][j] == 1) {
                            if (perm[k]>k+1) {
                                if (path[0][1]>j && path[path.length-1][1]<=j) {
                                    for (var t=0;t<path.length;t++) {
                                        if (path[t][0]<=i && path[t][1]>j) {
                                            plucker_label[i][j].push(perm[k]);
                                            break;
                                        }
                                    }
                                }
                            } else if (path[0][0]<=i || path[path.length-1][0]>i) {
                                plucker_label[i][j].push(perm[k]);
                            } else {
                                for (var t=0;t<path.length;t++) {
                                    if (path[t][0]<=i && path[t][1]>j) {
                                        plucker_label[i][j].push(perm[k]);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            grass_neck = targetGrassNeck(perm);
            source_grass_neck = [];
            for (var t=0;t<n;t++) {
                grass_neck[t] = backward_shift(grass_neck[t],min_element);
                source_grass_neck.push([]);
                for (var s=0;s<grass_neck[t].length;s++) {
                    source_grass_neck[t].push(original_perm.indexOf(grass_neck[t][s])+1);
                }
                source_grass_neck[t].sort((a,b) => a-b);
            }
            top_left_label = grass_neck[0].slice();
            if (face_label) {
                if (target_label) {
                    for (var i=0;i<m;i++) {
                        for (var j=0;j<n-m;j++) {
                            if (dyd[i][j]==1) {
                                plucker_label[i][j]=backward_shift(plucker_label[i][j],min_element);
                                ctx.textAlign = "center";
                                if (inList(plucker_label[i][j],grass_neck)>=0) {
                                    ctx.fillStyle = "blue";
                                    ctx.fillText(String(plucker_label[i][j]), h_gap*(j+1),v_gap*(i+1));
                                    ctx.fillStyle = "black";
                                } else {
                                    ctx.fillText(String(plucker_label[i][j]), h_gap*(j+1),v_gap*(i+1));
                                }
                            }
                        }
                    }
                    ctx.textAlign = "center";
                    ctx.fillStyle = "blue";
                    ctx.fillText(String(grass_neck[0]),h_gap*0.25,v_gap*0.25);
                    ctx.fillStyle = "black";
                } else {
                    for (var i=0;i<m;i++) {
                        for (var j=0;j<n-m;j++) {
                            if (dyd[i][j]==1) {
                                plucker_label[i][j]=backward_shift(plucker_label[i][j],min_element);
                                ctx.textAlign = "center";
                                if (inList(plucker_label[i][j],grass_neck)>=0) {
                                    ctx.fillStyle = "blue";
                                    ctx.fillText(String(targetToSource(plucker_label[i][j])), h_gap*(j+1),v_gap*(i+1));
                                    ctx.fillStyle = "black";
                                } else {
                                    ctx.fillText(String(targetToSource(plucker_label[i][j])), h_gap*(j+1),v_gap*(i+1));
                                }
                            }
                        }
                    }
                    ctx.textAlign = "center";
                    ctx.fillStyle = "blue";
                    ctx.fillText(String(targetToSource(grass_neck[0])),h_gap*0.25,v_gap*0.25);
                    ctx.fillStyle = "black";
                }
            }
            seed = ex_mat(dyd);
            if (quiver) {
                for (var t=0;t<seed[1].length;t++) {
                    for (var s=0;s<seed[1].length;s++) {
                        if (seed[2][t][s]>0) {
                            arrow([h_gap*(seed[1][t][1]+1),v_gap*(seed[1][t][0]+1)],[h_gap*(seed[1][s][1]+1),v_gap*(seed[1][s][0]+1)]);
                        }
                    }
                }
            }
            //document.getElementById("Poisson_bracket").innerHTML = "";
            document.getElementById("output").innerHTML = "This is a positroid cell in Gr("+m+","+n+").";
            if (nolistener) {
                diag.addEventListener("click",function(evt){
                    selected_face = getFace(diag, evt);
                    mouseClick(selected_face);
                })
                nolistener = false;
            }
            //the vertex index for each face, where the vertex is in the decorated Young diagram, and the exchange matrix.
            var frozen_index = [];
            for (var i=0;i<n;i++) {
                frozen_index.push(0);
            }
            for (var i=0;i<seed[1].length-1;i++) {
                if (inList(plucker_label[seed[1][i][0]][seed[1][i][1]],grass_neck)>=0) {
                    frozen_index[inList(plucker_label[seed[1][i][0]][seed[1][i][1]],grass_neck)] = i;
                }
            }
            frozen_index[0] = seed[1].length-1;
            console.log(frozen_index);
            outer_poisson = [];
            for (var i=0;i<n;i++) {
                outer_poisson.push([]);
                for (var j=0;j<n;j++) {
                    outer_poisson[i].push(0);
                }
            }
            for (var i=0;i<n;i++) {
                if (i==0) {
                    var x1 = xcoord(0);
                } else {
                    var x1 = xcoord(seed[1][frozen_index[i]]);
                }
                for (var j=0;j<n;j++) {
                    if (j==0) {
                        var x2 = xcoord(0);
                    } else {
                        var x2 = xcoord(seed[1][frozen_index[j]]);
                    }
                    outer_poisson[(i-min_element+n+1)%n][(j-min_element+n+1)%n] = seed[2][frozen_index[i]][frozen_index[j]]-monomial_pairing(x1[0],x1[1],x2[0],x2[1]);
                }
            } 
            document.getElementById("fr_mat").innerHTML = "The Poisson bracket between \\(\\frac{\\phi(i)}{i+1}\\) and \\(\\frac{\\phi(j)}{j+1}\\) is given by<br> \\begin{array} \\\\ ";
            for (var i=0;i<n;i++) {
                for (var j=0;j<n;j++) {
                    document.getElementById("fr_mat").innerHTML += String(outer_poisson[i][j]);
                    if (j<n-1) {
                        document.getElementById("fr_mat").innerHTML += "&";
                    } else if (i<n-1) {
                        document.getElementById("fr_mat").innerHTML += "\\\\";
                    }
                }
            }
            document.getElementById("fr_mat").innerHTML += "\\end{array}";
            MathJax.Hub.Typeset();
        }

        function getFace(diag, evt) { //returns the location of the face selected. It returns 0 if it is the face at the top left; otherwise it returns the matrix entry of the decorated Young diagram.
                var result = null;
                var rect = diag.getBoundingClientRect();
                if (Math.abs(evt.clientX-(rect.left+(0.25)*h_gap))+Math.abs(evt.clientY-(rect.top+(0.25)*v_gap))<20) {
                    result = 0;
                } else {
                    for (var j=0;j<plucker_label[0].length;j++) {
                        for (var i=0;i<plucker_label.length;i++) {
                            if (plucker_label[i][j].length>0 && Math.abs(evt.clientX-(rect.left+(j+1)*h_gap))+Math.abs(evt.clientY-(rect.top+(i+1)*v_gap))<20) {
                                result = [i,j];
                            }
                        }
                    }
                }
                if (result != null) {
                    return(result);
                }
            }

        function Poisson() {
            state = 1;
            double = [];
        }

        function PoissonA() {
            state = 2;
            double = [];
        }


        function Twist() {
            state = 3;
        }
        

        function binomial_enumerate(a,b,n) { //turns an index into a bi-index for an upper triangular matrix.
            var k = -1;
            var i = a;
            var j = b;
            while (i>0) {
                while (j>i+1) {
                    j -= 1;
                    k += 1;
                }
                k += 1;
                j = n;
                i -= 1;
            }
            return(k);
        }

        

        function mouseClick(face) {
            if (state == 3) {
                var selected = face;
                if (selected == 0) {
                    document.getElementById("Poisson_bracket").innerHTML = "The selected target Plucker is ["+String(grass_neck[0])+"]. After a left twist, it becomes <br>";
                    document.getElementById("Poisson_bracket").innerHTML += "\\(\\frac{1}{["+String(grass_neck[0])+"]}\\)";
                } else if (inList(plucker_label[selected[0]][selected[1]],grass_neck) >= 0) {
                    var t = inList(plucker_label[selected[0]][selected[1]],grass_neck);
                    document.getElementById("Poisson_bracket").innerHTML = "The selected target Plucker is ["+String(grass_neck[t])+"]. After a left twist, it becomes <br>";
                    document.getElementById("Poisson_bracket").innerHTML += "\\(\\frac{1}{["+String(grass_neck[t])+"]}\\)";
                } else {
                    document.getElementById("Poisson_bracket").innerHTML = "The selected target Plucker ["+String(plucker_label[face[0]][face[1]])+"] is unfrozen, which can be decomposed as<br>";
                    var right = 0;
                    var bottom = 0;
                    var w = seed[0][0].length;
                    var h = seed[0].length;
                    for (var i=0;i<w;i++) {
                        if (seed[0][selected[0]][w-i-1] > 0) {
                            right = w-i-1;
                            break;
                        }
                    }
                    for (var i=0;i<h;i++) {
                        if (seed[0][h-i-1][selected[1]] > 0){
                            bottom = h-i-1;
                            break;
                        }
                    }
                    var label_from_right = grass_neck[0].slice(selected[0]+1,)
                    var label_from_bottom = [];
                    for (var j=0;j<grass_neck[0].length;j++) {
                        if (label_from_right.indexOf(plucker_label[selected[0]][selected[1]][j])<0) {
                            label_from_bottom.push(plucker_label[selected[0]][selected[1]][j]);
                        }
                    }
                    label_from_right=reorder(label_from_right,(inList(plucker_label[selected[0]][right],grass_neck)+min_element+n-1+grass_neck[0].length)%n+1);
                    label_from_bottom=reorder(label_from_bottom,(inList(plucker_label[bottom][selected[1]],grass_neck)+min_element+n-1+grass_neck[0].length)%n+1);
                    //console.log(label_from_bottom,(inList(plucker_label[bottom][selected[1]],grass_neck)+min_element+n-1+grass_neck[0].length)%n+1);
		            document.getElementById("Poisson_bracket").innerHTML += "["+String(label_from_right)+"]U["+String(label_from_bottom)+"]<br>";
                    document.getElementById("Poisson_bracket").innerHTML +="After a left twist, it becomes <br> \\(";
                    var numerator = [];
                    var twisted_factor_1 = [];
                    var twisted_factor_2 = [];
                    for (t=0;t<label_from_right.length;t++) {
                        numerator = [];
                        for (s=0;s<source_grass_neck[0].length;s++) {
                            if (source_grass_neck[(label_from_right[t]+n-min_element+1)%n][s] != label_from_right[t]) {
                                numerator.push(source_grass_neck[(label_from_right[t]+n-min_element+1)%n][s]);
                            }
                        }
                        numerator=reorder(numerator,label_from_right[t]);
                        if (t==0) {
                            twisted_factor_1 = "\\frac{["+String(numerator.slice(numerator.length-label_from_bottom.length,))+"]}{["+String(source_grass_neck[(label_from_right[t]+n-min_element+1)%n])+"]}";
                        } else {
                            twisted_factor_1 += "\\frac{["+String(source_grass_neck[(label_from_right[t]+n-min_element)%n])+"]}{["+String(source_grass_neck[(label_from_right[t]+n-min_element+1)%n])+"]}";
                        }
                        numerator.sort((x,y)=>x-y);
                        document.getElementById("Poisson_bracket").innerHTML += "\\frac{["+String(numerator)+"]}{["+String(source_grass_neck[(label_from_right[t]+n-min_element+1)%n])+"]}\\wedge";
                    }
                    for (t=0;t<label_from_bottom.length;t++) {
                        numerator = [];
                        for (s=0;s<source_grass_neck[0].length;s++) {
                            if (source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n][s] != label_from_bottom[t]) {
                                numerator.push(source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n][s]);
                            }
                        }
                        numerator=reorder(numerator,label_from_bottom[t]);
                        if (t==0) {
                            twisted_factor_2 = "\\frac{[";
                            var inv = [];
                            for (var j=0;j<label_from_bottom.length;j++) {
                                inv.push(original_perm.indexOf(label_from_bottom[j])+1);
                            }
                            for (var j=0;j<source_grass_neck[0].length;j++) {
                                if (inv.indexOf(source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n][j])<0 && source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n][j]!=label_from_bottom[0]) {
                                    twisted_factor_2 += String(source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n][j])+","
                                }
                            }
                            twisted_factor_2 = twisted_factor_2.slice(0,-1);
                            twisted_factor_2 += "]}{["+String(source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n])+"]}";
                        } else {
                            twisted_factor_2 += "\\frac{["+String(source_grass_neck[(label_from_bottom[t]+n-min_element)%n])+"]}{["+String(source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n])+"]}";
                        }
                        numerator.sort((x,y)=>x-y);
                        document.getElementById("Poisson_bracket").innerHTML += "\\frac{["+String(numerator)+"]}{["+String(source_grass_neck[(label_from_bottom[t]+n-min_element+1)%n])+"]}";
                        if (t<label_from_bottom.length-1) {
                            document.getElementById("Poisson_bracket").innerHTML += "\\wedge";
                        }
                    }
                    document.getElementById("Poisson_bracket").innerHTML += "="+twisted_factor_1+"\\wedge"+twisted_factor_2+"\\)";
                }
            } else if (state == 2) {
                if (double.length == 0){
                    double.push(face);
                } else {
                    double.push(face);
                    var a = acoord(double[0]);
                    var b = acoord(double[1]);
                    document.getElementById("Poisson_bracket").innerHTML = "The selected Pluckers are <br>";
                    document.getElementById("Poisson_bracket").innerHTML += "["+String(a)+"] and ["+String(b)+"]. <br> Their log Poisson bracket is equal to ";
                    document.getElementById("Poisson_bracket").innerHTML += String(simple_pairing(a,b))+".";
                    double = [];
                }
            } else if (state == 1) {
                if (double.length == 0) {
                    double.push(face);
                } else {
                    double.push(face);
                    var a = xcoord(double[0])[0];
                    var b = xcoord(double[0])[1];
                    var e = xcoord(double[0])[2];
                    var c = xcoord(double[1])[0];
                    var d = xcoord(double[1])[1];
                    var f = xcoord(double[1])[2];
                    console.log("the selected faces correspond to the following monomials:");
                    console.log(a,b,c,d,e,f);
                    var output = monomial_pairing(a,b,c,d);
                    if (e.length > 0  && f.length > 0) {
                        output += outer_poisson[e[0]-1][f[0]-1];
                    }
                    document.getElementById("Poisson_bracket").innerHTML = "The cluster X variables are <br>";
                    if (a.length > 0) {
                        document.getElementById("Poisson_bracket").innerHTML += "\\(\\frac{";
                        for (var t=0;t<a.length;t++) {
                            document.getElementById("Poisson_bracket").innerHTML += "["+String(a[t])+"]";
                        }
                        document.getElementById("Poisson_bracket").innerHTML += "}{";
                        for (var t=0;t<b.length;t++) {
                            document.getElementById("Poisson_bracket").innerHTML += "["+String(b[t])+"]";
                        }
                        document.getElementById("Poisson_bracket").innerHTML += "}";
                    } else {
                        document.getElementById("Poisson_bracket").innerHTML += "\\(\\frac{";
                    }
                    if (e.length > 0) {
                        document.getElementById("Poisson_bracket").innerHTML += "\\frac{\\phi("+String(e[0])+")}{"+String((e[0])%n+1)+"}";
                    }
                    document.getElementById("Poisson_bracket").innerHTML += "\\)";
                    document.getElementById("Poisson_bracket").innerHTML +="<br> and <br>";
                    if (c.length > 0) {
                        document.getElementById("Poisson_bracket").innerHTML += "\\(\\frac{";
                        for (var t=0;t<c.length;t++) {
                            document.getElementById("Poisson_bracket").innerHTML += "["+String(c[t])+"]";
                        }
                        document.getElementById("Poisson_bracket").innerHTML += "}{";
                        for (var t=0;t<d.length;t++) {
                            document.getElementById("Poisson_bracket").innerHTML += "["+String(d[t])+"]";
                        }
                        document.getElementById("Poisson_bracket").innerHTML += "}";
                    } else {
                        document.getElementById("Poisson_bracket").innerHTML += "\\(\\frac{";
                    }
                    if (f.length > 0) {
                        document.getElementById("Poisson_bracket").innerHTML += "\\frac{\\phi("+String(f[0])+")}{"+String((f[0])%n+1)+"}";
                    }
                    document.getElementById("Poisson_bracket").innerHTML += "\\)";
                    document.getElementById("Poisson_bracket").innerHTML +=".<br> Their Poisson bracket is equal to "+output+".";
                    double = [];
                }
            }
            MathJax.Hub.Typeset();
        }



    </script>
</html>